---
applyTo: "packages/core/src/utils/**/*.ts,packages/core/src/components/**/*.astro,packages/core/src/layouts/**/*.astro,packages/core/src/routes/**/*.ts"
---

# Implementation Instructions

## Monorepo Context
You are working inside an NPM Workspaces monorepo. The framework lives in
`packages/core/` and the playground in `playground/` (ephemeral, gitignored).
All business logic belongs in `packages/core/src/utils/`. The playground
imports the framework only via `@community-rss/core`.

## Utils Organization
Before creating a new utility:
1. Search existing utils for similar functionality
2. Choose correct directory by execution context:
   - `utils/build/` — Runs on Node.js server only (cron, sync, email, auth)
   - `utils/client/` — Runs in browser (DOM, interactions UI)
   - `utils/shared/` — Pure functions (validation, formatting, scoring)
3. Database queries live in `src/db/` — not in utils

## Function Standards
- Export all functions that need testing
- Use TypeScript `interface` for parameter objects and return types
- Add JSDoc comments with `@param`, `@returns`, and `@since` version tags
- Keep functions pure when possible
- Public APIs (exported from `index.ts`) must be forward-compatible

## Component Standards
- Components are thin wrappers — NO business logic
- Import logic from `../utils/` (relative in source)
- Accept `messages`/`labels` props — all user-facing strings are configurable
- No hard-coded copy; framework strings default via optional props
- Use CSS custom properties for all themeable values (no hard-coded colours)
- Provide sensible visual defaults that consumers can override
- Use `<style is:global>` with `@layer crss-components { ... }` for styles
- All CSS class names must use the `crss-` prefix (e.g., `.crss-feed-card`)
- No `:global()` wrappers — `is:global` makes them redundant
- All visual values must reference `--crss-comp-*` or `--crss-sys-*` tokens

## Slot Architecture
All core components, layouts, and pages expose named slots for the
proxy ejection system. When adding or modifying slots:

- **Generic wrapper slots**: Every component/layout/page MUST have
  `before-unnamed-slot` and `after-unnamed-slot` extension slots
- **Structural slots**: Complex components expose meaningful sections
  (e.g., `header`, `body`, `footer` on ArticleModal; `form`, `confirmation`
  on SignUpForm)
- **Content super-slot**: All pages wrap their `<main>` content in
  `<slot name="content">...</slot>` with existing markup as fallback
- **Default slot**: Use `<slot />` as a passthrough for the unnamed slot
- Use slot fallback content (not `Astro.slots.has()`) for conditional
  rendering — Astro forwarding causes `has()` to return true for empty
  forwarded slots
- Always update `src/cli/slot-registry.mjs` when adding/changing slots
- Slot order matters: appears in registry order in the generated proxy

## Import Standards
- **Source code** (`src/`): Use **relative imports** for all cross-directory
  imports (e.g., `../types/options`). Path aliases in source code break
  consumers because Astro/Vite cannot resolve the core package's internal
  tsconfig aliases when consumed as a workspace dependency.
- Same-directory imports may use relative paths (`./sibling`)
- **Test code** uses path aliases — see the testing instructions for details.

### Path Alias Reference (Test Code Only)
| Path Alias | Maps To | Usage |
|------------|---------|-------|
| `@utils/*` | `src/utils/*` | Utility function imports |
| `@components/*` | `src/components/*` | Component imports |
| `@routes/*` | `src/routes/*` | Route handler imports |
| `@db/*` | `src/db/*` | Database queries & schema |
| `@core-types/*` | `src/types/*` | TypeScript interfaces |
| `@layouts/*` | `src/layouts/*` | Layout imports |
| `@cli/*` | `src/cli/*` | CLI scaffold code |

## Runtime Context (AppContext)
- Runtime context is provided by `AppContext` (`src/types/context.ts`)
- `AppContext` contains `db` (BetterSQLite3Database), `env`
  (EnvironmentVariables), and `config` (CommunityRssOptions)
- Accessed in route handlers via `context.locals.app`
- Environment variables are typed in `EnvironmentVariables` interface and
  read from `process.env`
- The `PUBLIC_SITE_URL` env var must match the externally-accessible origin
  (e.g., `http://localhost:4321` in local dev) — without this, better-auth
  magic links and cookies fail silently
- Authentication via `better-auth` — never implement custom session logic

## Database
- Use Drizzle ORM with better-sqlite3 (`BetterSQLite3Database`) for all
  queries — never use raw SQL outside generated migrations
- SQL migration files are generated by `drizzle-kit generate` — never
  hand-written
- The Drizzle TypeScript schema (`src/db/schema.ts`) is the single source
  of truth for database structure
- Database seed data (e.g., the System User) should be created via query
  helpers, not hand-written SQL
- The "System User" (`id: 'system'`) owns global/community feeds and must
  exist before any feed operations — seeded during DB setup

## Authentication
- better-auth handles all auth concerns — sessions, magic links, sign-out
- Auth routes use a single catch-all at `/api/auth/[...all]` that delegates
  to `auth.handler()` — never create manual auth endpoint wrappers
- Protected `/api/v1/` routes extract session via `auth.api.getSession()`
- Admin role checks must use the framework's user tier system
- Admin users bypass domain verification for feed submission

## Email Templates
- File-based HTML templates with `{{variable}}` substitution
- Resolution order: custom code → developer HTML → Astro Container →
  package HTML → code defaults (5-step chain)
- HTML templates live in `src/templates/email-templates/` (package defaults)
- Astro email components live in `src/templates/email/` (Container API)
- Scaffolded to developer project via CLI `init` command
- Subject line extracted from `<!-- subject: ... -->` HTML comment
- Never hard-code email content in utility functions

### Astro Email Components (`src/templates/email/`)
- Use `EmailLayout.astro` as the shared wrapper (table-based layout)
- Accept props like `{ url, appName, greeting }` — typed and validated
- Use inline styles (not CSS classes) — email clients require it
- `renderAstroEmail(Component, props)` renders via Container API + juice
  for CSS inlining
- Container API requires Astro's Vite pipeline — returns `null` gracefully
  in test environments without it

## Route Architecture
- **API routes** (11) are injected by the integration into `/api/v1/...`
  and `/api/auth/[...all]`
- **Page routes** (8) are injected conditionally by the integration. If a
  developer has a local file at the corresponding path, the framework
  skips injection for that route. Pages are not scaffolded by `init`.
- To take ownership of a page: `npx crss eject pages/<name>`
- Pages fetch data client-side from API routes
- Components accept configurable `messages`/`labels` props for all
  user-facing strings

## Astro Actions
- Action handlers are pure functions in `src/actions/` with signature:
  `(input: T, app: AppContext) => Promise<Result>`
- `src/actions/definitions.ts` exports `coreActions` — a map of all
  framework actions with Zod schemas and handlers
- Consumers use `coreActions` spread in their `src/actions/index.ts`:
  `...wrapCoreActions(coreActions)` + `defineAction()` wrapper
- The core package CANNOT import `astro:actions` — only consumer projects can
- Action handlers are exported from `@community-rss/core/actions`
- Client-side code calls `actions.fetchArticles(input)` through Astro's
  built-in action system — no manual `fetch()` calls needed

### Writing a New Action Handler
1. Create handler function in `src/actions/{domain}.ts`
2. Export from `src/actions/index.ts` barrel
3. Re-export from `packages/core/index.ts` with JSDoc `@since`
4. Add Zod-validated `defineAction` wrapper to scaffold template
5. Write tests: `test/actions/{domain}.test.ts`

## Server Islands
- Auth-dependent UI (AuthButton, HomepageCTA) uses `server:defer` to
  stream content after the initial page shell loads
- These components perform server-side session checks via
  `createAuth(app).api.getSession()` — no client-side fetch needed
- Always provide a `slot="fallback"` with a loading skeleton
- Components using `server:defer` must accept their context from
  `Astro.locals.app` rather than props passed from the parent page

## Background Processing
- Uses `node-cron` for scheduled tasks (feed sync, cleanup)
- Cron jobs registered during integration `astro:server:setup` hook
- Direct function calls replace the old queue pattern
- `syncFeeds()` and `processArticles()` run in-process on the server

## Config Bridge (config-store.ts)
- `src/config-store.ts` passes resolved integration config from
  `astro:config:setup` (where the integration runs) to the middleware
  (which runs at request time) via `globalThis.__communityRssConfig`
- `setGlobalConfig(config)` is called in `integration.ts` during setup
- `getGlobalConfig()` is called in `middleware.ts` on each request
- This avoids Astro virtual module imports at config-load time, which
  fail because virtual modules are only available inside Vite's plugin
  system
- `config-store.ts` has zero Astro imports to keep it safe for both
  integration hooks and middleware runtime

## Middleware
- `middleware.ts` exports `onRequest` directly (not a factory function)
- It reads config via `getGlobalConfig()` from the config-store bridge
- It creates `AppContext` with `{ db, config, env }` and sets `locals.app`
- Database connection uses a singleton pattern with auto-migration

## Playground Development
- The playground is **ephemeral** — gitignored and rebuilt via
  `scripts/reset-playground.sh`
- **Backend changes are instant**: API routes, middleware, components, and
  utils are symlinked from `packages/core/` via NPM workspaces. Edit and
  the dev server hot-reloads automatically.
- **Page/template changes need a reset**: After editing CLI templates in
  `src/cli/templates/`, run `npm run reset:playground` to rebuild. The
  database and test accounts are preserved by default.
- `npm run hardreset:playground` does a full clean including wiping the DB.

## Styling
- Use CSS custom properties (e.g., `--crss-surface`, `--crss-text`, `--crss-brand`)
- Prefix all framework tokens with `--crss-` to avoid consumer namespace collisions
- Framework ships sensible defaults; consumers remap tokens via `theme.css`
  or integration config
- No hardcoded colour, spacing, or font values in components — always use
  CSS custom properties

### Three-Tier Token System
- **Tier 1 — Reference** (`--crss-ref-*`): Raw palette values, spacing/type
  scales. Defined in `src/styles/tokens/reference.css`.
- **Tier 2 — System** (`--crss-sys-*`): Semantic roles mapping refs to meaning
  (e.g., `--crss-sys-color-primary`). Backward-compatible flat aliases
  (`--crss-surface-0`, `--crss-text-primary`, etc.) are defined here.
  In `src/styles/tokens/system.css`.
- **Tier 3 — Component** (`--crss-comp-*`): Component-scoped overrides
  (e.g., `--crss-comp-card-bg`). In `src/styles/tokens/components.css`.

### Token Naming Conventions
| Tier | Prefix | Example | Purpose |
|------|--------|---------|---------|
| Reference | `--crss-ref-` | `--crss-ref-gray-900` | Raw palette value |
| System | `--crss-sys-` | `--crss-sys-color-primary` | Semantic role |
| Component | `--crss-comp-` | `--crss-comp-card-bg` | Component-scoped override |
| Flat alias | `--crss-` | `--crss-surface-0` | Backward-compatible shorthand |

### CSS Cascade Layers
- Layer order: `crss-reset, crss-tokens, crss-base, crss-components, crss-utilities`
- Defined in `src/styles/layers.css` and injected by the integration
- Consumer `theme.css` is un-layered so it always wins
- Components use `@layer crss-components { ... }` when declaring styles
  outside Astro scoped `<style>` blocks
- All token definitions must be inside `@layer crss-tokens`
- Never define styles outside `@layer` in framework CSS

## Proxy Component Pattern
Components in the core package own logic and default styling. When scaffolded
into a developer's project, **Proxy Wrappers** import the core component
and add a local `<style>` block for customisation.

**Why:** Developers own their styling (survives package updates) while the
package owns logic (improvements flow through automatically).

```astro
---
// Developer's src/components/FeedCard.astro (scaffolded proxy wrapper)
import CoreFeedCard from '@community-rss/core/components/FeedCard.astro';
const props = Astro.props;
---
<div class="my-feed-card">
  <CoreFeedCard {...props} />
</div>
<style>
  /* Custom styles scoped to this wrapper */
  .my-feed-card :global(.crss-feed-card) {
    --crss-comp-card-bg: #1e293b;
  }
</style>
```

**Rules for proxy wrappers:**
- Import the core component from `@community-rss/core/components/*`
- Pass all props through via `{...props}` or `{...Astro.props}`
- No business logic, no API calls, no data transformation
- Only: styling overrides, slot content, surrounding markup, token overrides
- Override component tokens (`--crss-comp-*`) in the `<style>` block

## Example Pattern
```typescript
// ✅ GOOD: packages/core/src/utils/shared/scoring.ts
export interface TrendingOptions {
  /** Weight for hearts (0-1). @since 0.1.0 */
  heartWeight?: number;
  /** Weight for comments (0-1). @since 0.1.0 */
  commentWeight?: number;
  /** Time window in hours. @since 0.1.0 */
  windowHours?: number;
}

/**
 * Calculates a trending score for an article.
 * @param hearts - Number of hearts
 * @param comments - Number of comments
 * @param options - Scoring weights and window
 * @returns Normalised trending score
 * @since 0.1.0
 */
export function calculateTrendingScore(
  hearts: number,
  comments: number,
  options: TrendingOptions = {}
): number {
  const { heartWeight = 0.6, commentWeight = 0.4 } = options;
  return hearts * heartWeight + comments * commentWeight;
}
```

```astro
---
// ✅ GOOD: packages/core/src/components/TrendingBadge.astro
import { calculateTrendingScore } from '../utils/shared/scoring';

interface Props {
  hearts: number;
  comments: number;
  label?: string;
}

const { hearts, comments, label = 'Trending' } = Astro.props;
const score = calculateTrendingScore(hearts, comments);
---
<span class="trending-badge">{label}: {score}</span>
<style>
  .trending-badge { color: var(--crss-brand); }
</style>
```
