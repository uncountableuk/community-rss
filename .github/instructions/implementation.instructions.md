---
applyTo: "packages/core/src/utils/**/*.ts,packages/core/src/components/**/*.astro,packages/core/src/layouts/**/*.astro,packages/core/src/routes/**/*.ts"
---

# Implementation Instructions

## Monorepo Context
You are working inside an NPM Workspaces monorepo. The framework lives in
`packages/core/` and the playground in `playground/` (ephemeral, gitignored).
All business logic belongs in `packages/core/src/utils/`. The playground
imports the framework only via `@community-rss/core`.

## Utils Organization
Before creating a new utility:
1. Search existing utils for similar functionality
2. Choose correct directory by execution context:
   - `utils/build/` — Runs on Node.js server only (cron, sync, email, auth)
   - `utils/client/` — Runs in browser (DOM, interactions UI)
   - `utils/shared/` — Pure functions (validation, formatting, scoring)
3. Database queries live in `src/db/` — not in utils

## Function Standards
- Export all functions that need testing
- Use TypeScript `interface` for parameter objects and return types
- Add JSDoc comments with `@param`, `@returns`, and `@since` version tags
- Keep functions pure when possible
- Public APIs (exported from `index.ts`) must be forward-compatible

## Component Standards
- Components are thin wrappers — NO business logic
- Import logic from `../utils/` (relative in source)
- Accept `messages`/`labels` props — all user-facing strings are configurable
- No hard-coded copy; framework strings default via optional props
- Use CSS custom properties for all themeable values (no hard-coded colours)
- Provide sensible visual defaults that consumers can override

## Import Standards
- **Source code** (`src/`): Use **relative imports** for all cross-directory
  imports (e.g., `../types/options`). Path aliases in source code break
  consumers because Astro/Vite cannot resolve the core package's internal
  tsconfig aliases when consumed as a workspace dependency.
- Same-directory imports may use relative paths (`./sibling`)
- **Test code** uses path aliases — see the testing instructions for details.

### Path Alias Reference (Test Code Only)
| Path Alias | Maps To | Usage |
|------------|---------|-------|
| `@utils/*` | `src/utils/*` | Utility function imports |
| `@components/*` | `src/components/*` | Component imports |
| `@routes/*` | `src/routes/*` | Route handler imports |
| `@db/*` | `src/db/*` | Database queries & schema |
| `@core-types/*` | `src/types/*` | TypeScript interfaces |
| `@layouts/*` | `src/layouts/*` | Layout imports |
| `@cli/*` | `src/cli/*` | CLI scaffold code |

## Runtime Context (AppContext)
- Runtime context is provided by `AppContext` (`src/types/context.ts`)
- `AppContext` contains `db` (BetterSQLite3Database), `env`
  (EnvironmentVariables), and `config` (CommunityRssOptions)
- Accessed in route handlers via `context.locals.app`
- Environment variables are typed in `EnvironmentVariables` interface and
  read from `process.env`
- The `PUBLIC_SITE_URL` env var must match the externally-accessible origin
  (e.g., `http://localhost:4321` in local dev) — without this, better-auth
  magic links and cookies fail silently
- Authentication via `better-auth` — never implement custom session logic

## Database
- Use Drizzle ORM with better-sqlite3 (`BetterSQLite3Database`) for all
  queries — never use raw SQL outside generated migrations
- SQL migration files are generated by `drizzle-kit generate` — never
  hand-written
- The Drizzle TypeScript schema (`src/db/schema.ts`) is the single source
  of truth for database structure
- Database seed data (e.g., the System User) should be created via query
  helpers, not hand-written SQL
- The "System User" (`id: 'system'`) owns global/community feeds and must
  exist before any feed operations — seeded during DB setup

## Authentication
- better-auth handles all auth concerns — sessions, magic links, sign-out
- Auth routes use a single catch-all at `/api/auth/[...all]` that delegates
  to `auth.handler()` — never create manual auth endpoint wrappers
- Protected `/api/v1/` routes extract session via `auth.api.getSession()`
- Admin role checks must use the framework's user tier system
- Admin users bypass domain verification for feed submission

## Email Templates
- File-based HTML templates with `{{variable}}` substitution
- Resolution order: developer directory → package defaults → code-based
  fallbacks
- Templates live in `src/templates/email-templates/` (package defaults)
- Scaffolded to developer project via CLI `init` command
- Subject line extracted from `<!-- subject: ... -->` HTML comment
- Never hard-code email content in utility functions

## Route Architecture
- **API routes** (11) are injected by the integration into `/api/v1/...`
  and `/api/auth/[...all]`
- **Page routes** (8) are developer-owned, scaffolded via
  `npx @community-rss/core init` — never injected by the integration
- Pages fetch data client-side from API routes
- Components accept configurable `messages`/`labels` props for all
  user-facing strings

## Background Processing
- Uses `node-cron` for scheduled tasks (feed sync, cleanup)
- Cron jobs registered during integration `astro:server:setup` hook
- Direct function calls replace the old queue pattern
- `syncFeeds()` and `processArticles()` run in-process on the server

## Config Bridge (config-store.ts)
- `src/config-store.ts` passes resolved integration config from
  `astro:config:setup` (where the integration runs) to the middleware
  (which runs at request time) via `globalThis.__communityRssConfig`
- `setGlobalConfig(config)` is called in `integration.ts` during setup
- `getGlobalConfig()` is called in `middleware.ts` on each request
- This avoids Astro virtual module imports at config-load time, which
  fail because virtual modules are only available inside Vite's plugin
  system
- `config-store.ts` has zero Astro imports to keep it safe for both
  integration hooks and middleware runtime

## Middleware
- `middleware.ts` exports `onRequest` directly (not a factory function)
- It reads config via `getGlobalConfig()` from the config-store bridge
- It creates `AppContext` with `{ db, config, env }` and sets `locals.app`
- Database connection uses a singleton pattern with auto-migration

## Playground Development
- The playground is **ephemeral** — gitignored and rebuilt via
  `scripts/reset-playground.sh`
- **Backend changes are instant**: API routes, middleware, components, and
  utils are symlinked from `packages/core/` via NPM workspaces. Edit and
  the dev server hot-reloads automatically.
- **Page/template changes need a reset**: After editing CLI templates in
  `src/cli/templates/`, run `npm run reset:playground` to rebuild. The
  database and test accounts are preserved by default.
- `npm run hardreset:playground` does a full clean including wiping the DB.

## Styling
- Use CSS custom properties (e.g., `--crss-surface`, `--crss-text`, `--crss-brand`)
- Prefix all framework tokens with `--crss-` to avoid consumer namespace collisions
- Framework ships sensible defaults; consumers remap tokens via `theme.css`
  or integration config
- Three-tier token system: Reference (`--crss-ref-*`), System (`--crss-sys-*`),
  Component (`--crss-comp-*`). Backward-compatible flat aliases (`--crss-*`)
  map to system tokens.
- No hardcoded colour, spacing, or font values in components — always use
  CSS custom properties

## Proxy Component Pattern
Components in the core package own logic and default styling. When scaffolded
into a developer's project, **Proxy Wrappers** import the core component
and add a local `<style>` block for customisation.

**Why:** Developers own their styling (survives package updates) while the
package owns logic (improvements flow through automatically).

```astro
---
// Developer's src/components/FeedCard.astro (scaffolded proxy wrapper)
import CoreFeedCard from '@community-rss/core/components/FeedCard.astro';
const props = Astro.props;
---
<div class="my-feed-card">
  <CoreFeedCard {...props} />
</div>
<style>
  /* Custom styles scoped to this wrapper */
  .my-feed-card :global(.crss-feed-card) {
    --crss-comp-card-bg: #1e293b;
  }
</style>
```

**Rules for proxy wrappers:**
- Import the core component from `@community-rss/core/components/*`
- Pass all props through via `{...props}` or `{...Astro.props}`
- No business logic, no API calls, no data transformation
- Only: styling overrides, slot content, surrounding markup, token overrides
- Override component tokens (`--crss-comp-*`) in the `<style>` block

## Example Pattern
```typescript
// ✅ GOOD: packages/core/src/utils/shared/scoring.ts
export interface TrendingOptions {
  /** Weight for hearts (0-1). @since 0.1.0 */
  heartWeight?: number;
  /** Weight for comments (0-1). @since 0.1.0 */
  commentWeight?: number;
  /** Time window in hours. @since 0.1.0 */
  windowHours?: number;
}

/**
 * Calculates a trending score for an article.
 * @param hearts - Number of hearts
 * @param comments - Number of comments
 * @param options - Scoring weights and window
 * @returns Normalised trending score
 * @since 0.1.0
 */
export function calculateTrendingScore(
  hearts: number,
  comments: number,
  options: TrendingOptions = {}
): number {
  const { heartWeight = 0.6, commentWeight = 0.4 } = options;
  return hearts * heartWeight + comments * commentWeight;
}
```

```astro
---
// ✅ GOOD: packages/core/src/components/TrendingBadge.astro
import { calculateTrendingScore } from '../utils/shared/scoring';

interface Props {
  hearts: number;
  comments: number;
  label?: string;
}

const { hearts, comments, label = 'Trending' } = Astro.props;
const score = calculateTrendingScore(hearts, comments);
---
<span class="trending-badge">{label}: {score}</span>
<style>
  .trending-badge { color: var(--crss-brand); }
</style>
```
